var b=[],d=new Map,J=0,m=!0;function X(){return`signal_${++J}_${Date.now()}`}function $(e,n,t){let r={id:X(),type:e,createdAt:Date.now(),label:t};if(d.set(r.id,r),m){for(let i of b)if(i.onSignalCreate)try{i.onSignalCreate(r,n)}catch(s){console.error(`Error in plugin "${i.name}" onSignalCreate:`,s)}}return r}function D(e,n,t,r="set"){if(!m)return;let i=d.get(e);if(!i)return;let s={signal:i,oldValue:n,newValue:t,timestamp:Date.now(),source:r};for(let o of b)if(o.onSignalUpdate)try{o.onSignalUpdate(s)}catch(Y){console.error(`Error in plugin "${o.name}" onSignalUpdate:`,Y)}}function I(e){if(!m)return;let n=d.get(e);if(n){for(let t of b)if(t.onSignalDestroy)try{t.onSignalDestroy(n)}catch(r){console.error(`Error in plugin "${t.name}" onSignalDestroy:`,r)}d.delete(e)}}var l=1,v=2,S=4,T=8,R=16,A=1e4,B=new Array(A),p=0;function ee(e){p<A&&(e.value=void 0,e.subscribers=null,e.listeners=null,e.dependencies=null,e.computeFn=null,e.flags=0,B[p++]=e)}var f=new WeakMap,k=new Map;var U=1e4,N=new Array(U),u=0,c=0,h=!1;function ne(e){if(e.flags&v)return;let n=(c+1)%U;n===u&&(console.error("[SignalForge] Batch queue overflow \u2192 forcing flush"),x()),e.flags|=v,N[c]=e,c=n,h||(h=!0,queueMicrotask(x))}function x(){for(h=!1;u!==c;){let e=N[u];u=(u+1)%U,e.flags&=~v,e.flags&l&&g(e)}}var F=new Array(100),L=0,a=null;function te(e){F[L++]=a,a=e}function re(){a=F[--L]}var ie=function(){return this._node.value},oe=function(e){this._node.subscribers||(this._node.subscribers=new Set),this._node.subscribers.add(e)},ae=function(e){this._node.subscribers&&this._node.subscribers.delete(e)};function P(e,n=null){let t=p>0?B[--p]:{value:void 0,subscribers:null,listeners:null,dependencies:null,computeFn:null,flags:0};return t.value=e,t.computeFn=n,t.flags=n?R|l:0,n&&g(t),t}function H(e,n){return a?(a!==e&&(q(e,a),ue(a,n)),e.flags&l&&e.computeFn&&g(e),e.value):(e.flags&l&&e.computeFn&&g(e),e.value)}function se(e,n,t){if(e.flags&R)throw new Error("Cannot set computed signal");if(typeof t=="function"&&(t=t(e.value)),Object.is(t,e.value))return;let r=e.value;e.value=t;let i=f.get(n);i&&D(i,r,t,"set"),G(e)}function q(e,n){e.subscribers||(e.subscribers=new Set),e.subscribers.add(n)}function le(e,n){e.subscribers&&e.subscribers.delete(n)}function ue(e,n){e.dependencies||(e.dependencies=new Set),e.dependencies.has(n)||(e.dependencies.add(n),q(n._node,e))}function j(e){if(e.dependencies){for(let n of e.dependencies)le(n._node,e);e.dependencies.clear()}}function w(e){if(!(e.flags&l)&&(e.flags|=l,ne(e),e.subscribers))for(let n of e.subscribers)w(n)}function g(e){if(e.computeFn&&!(e.flags&S)){e.flags|=S,j(e),te(e);try{let n=e.computeFn();e.flags&=~l,e.flags&=~S,Object.is(n,e.value)||(e.value=n,G(e))}finally{re()}}}function G(e){if(e.subscribers)for(let n of e.subscribers)w(n);if(e.flags&T&&e.listeners)for(let n of e.listeners)n(e.value)}function O(e,n){return e.listeners||(e.listeners=new Set),e.listeners.add(n),e.flags|=T,()=>{e.listeners.delete(n),e.listeners.size===0&&(e.flags&=~T)}}function _(e){j(e),e.subscribers&&e.subscribers.clear(),e.listeners&&e.listeners.clear(),ee(e)}function C(e){let n=P(e,null),t={get:()=>H(n,t),set:i=>se(n,t,i),subscribe:i=>O(n,i),destroy:()=>{let i=f.get(t);i&&(I(i),k.delete(i),f.delete(t)),_(n)},_node:n,_peek:ie,_addSubscriber:oe,_removeSubscriber:ae},r=$("signal",e);return f.set(t,r.id),k.set(r.id,t),t}function ce(e){let n,t=a;a=null;try{n=e()}finally{a=t}let r=P(n,e),i={get:()=>H(r,i),set:()=>{throw new Error("Cannot set a computed signal")},subscribe:s=>O(r,s),destroy:()=>_(r),_node:r,_peek:()=>r.value,_addSubscriber:s=>{r.subscribers||(r.subscribers=new Set),r.subscribers.add(s)},_removeSubscriber:s=>{r.subscribers&&r.subscribers.delete(s)},_markDirty:()=>w(r),_recompute:()=>g(r)};return i}function E(e){let n=P(void 0,e);return()=>_(n)}function ge(e){let n=e();return W(),n}function W(){u!==c&&x()}function de(e){let n=a;a=null;try{return e()}finally{a=n}}var fe=W;import{useState as V,useEffect as z}from"react";function pe(){if(typeof V!="function"||typeof z!="function")throw new Error(`[SignalForge] React hooks unavailable. Possible duplicate React instance or invalid bundler resolution.
Troubleshooting:
  1. Ensure only one react copy: node_modules/react (no nested copy under library).
  2. Clear Metro cache: npx react-native start --reset-cache.
  3. Verify metro.config.js extraNodeModules maps react to example app node_modules.`)}pe();function K(e){let[n,t]=V(()=>e.get());return z(()=>(t(e.get()),e.subscribe(()=>t(e.get()))),[e]),n}function ye(e){let[n]=V(()=>{let r=typeof e=="function"?e():e;return C(r)});return[K(n),n.set.bind(n)]}import{useEffect as be,useRef as M}from"react";var y=new WeakMap;function me(e,n=[]){let t=M({}),r=M(null),i=M(null);be(()=>{let s=()=>{if(!y.get(t.current)){y.set(t.current,!0);try{r.current&&(r.current(),r.current=null);let o=e();typeof o=="function"&&(r.current=o)}finally{y.set(t.current,!1)}}};return i.current=E(s),()=>{r.current&&r.current(),i.current&&i.current(),y.delete(t.current)}},n)}import Se from"react";import{jsx as he}from"react/jsx-runtime";function Q(e){let n={};for(let t of Object.keys(e))n[t]=e[t].get();return n}function ve(e){return e.displayName||e.name||"Component"}function Z(e,n,t){var r;return r=class extends Se.Component{constructor(o){super(o);this.unsubscribers=[];this.state=Q(n)}componentDidMount(){this.unsubscribeAll(),this.setState(Q(n)),this.unsubscribers=Object.keys(n).map(o=>n[o].subscribe(()=>{this.setState({[o]:n[o].get()})}))}componentWillUnmount(){this.unsubscribeAll()}unsubscribeAll(){for(let o of this.unsubscribers)o();this.unsubscribers=[]}render(){return he(e,{...this.props,...this.state})}},r.displayName=t?.displayName||`WithSignals(${ve(e)})`,r}function Te(e,n,t){return Z(e,{value:n},{displayName:t?.displayName})}export{ge as batch,ce as createComputed,E as createEffect,C as createSignal,fe as flushSync,de as untrack,ye as useSignal,me as useSignalEffect,K as useSignalValue,Te as withSignalValue,Z as withSignals};
